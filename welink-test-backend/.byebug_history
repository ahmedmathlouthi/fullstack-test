continue
User.where(email: "test@test.com").count
feedback
feedback = valid_feedback.merge(user: user_info_static_email)
valid_feedback
user_info_static_email
continue
valid_feedback.merge(user: user_info_attributes)
valid_feedback.merge(user_info_attributes)
valid_feedback.merge(user: {firstname: 'testuser'})
valid_feedback
FactoryBot.attributes_for(:feedback, body: 'test', user: user_info_attributes)
FactoryBot.attributes_for(:user, :valid)
user_info_attributes
FactoryBot.attributes_for(:feedback, body: 'test', user: user_info_attributes)
valid_feedback
continue
user_info_attributes
valid_feedback
continue
feedback_params
params
continue
feedback_params
params
continue
params
feedback_params
continue
feedback_params[:user]
feedback_params
user_params
params
continue
feedback_params
user_params
params
continue
user.update(user_params)
user_params[:feedbacks]
user_params
params
continue
params
continue
user_params
params
continue
params
continue
params
continue
params
continue
params
continue
params
user_params
user_info_attributes
user_info
user
FactoryBot.attributes_for(:user, :valid, feedbacks: [feedback])
user_info_attributes
continue
params[:q] != ""
params[:q]
continue
params
seached_feedbacks
seached_feedbacks.any?
@feedbacks_selection.take(10).count
@feedbacks_selection.take(10)
@feedbacks_selection.count
continue
params.require(:feedback).permit(:firstname, :lastname, :email, feedback: {})
params.require(:user).permit(:firstname, :lastname, :email, feedback: {})
params.permit(:firstname, :lastname, :email, feedback: {})
user_params
params
continue
params.permit(:firstname, :lastname, :email, feedback: {})
params.permit(:firstname, :lastname, :email, feedback: [])
user_params
continue
user_params
params
continue
user_params
params[:feedback][:body]
params
user_params
continue
contineu
user.update(user_params)
user
continue
user
User.find_by(email: user_params[:email])
User.find_by(email: params[:email])
User.pluck(:email)
@user
user
continue
user
user.update(firstname: 'tezst')
user_params
user.present?
user.update(user_params)
user_params
user.errors
user.erros
user.valid?
user
continue
pagination_index
pagination_index.present?
continue
feedbacks[2..3].count
feedbacks[0..3].count
feedbacks[1..3].count
feedbacks[1..2].count
feedbacks[1..2]
pagination_index
arr.count
arr=[feedbacks[pagination_index]..feedbacks[pagination_index + 2]]
[feedbacks[pagination_index]..feedbacks[pagination_index + 2]]
feedbacks[pagination_index]..feedbacks[pagination_index + 2]
feedbacks[pagination_index]..feedbacks[pagination_index + pagination_items]
feedbacks[pagination_index]..feedbacks[pagination_index + 3]
feedbacks[pagination_index]..feedbacks[pagination_index + pagination_items]
paginated_array
continue
seached_users.order(order_attribute.to_s => order.to_sym).pluck(:firstname)
order = "asc"
order
seached_users.order(order_attribute.to_s => order.to_sym).pluck(:firstname)
exit
order
seached_users.order(order_attribute.to_s => order.to_sym).pluck(:firstname)
ordered_users.pluck(:firstname)
ordered_users
continue
seached_users.includes(:feedbacks).map(&:feedbacks).flatten
seached_users = ordered_users.where(firstname: seach_params)
ordered_users.where(firstname: seach_params)
seach_params
@ordered_users.count
@ordered_users
@ordered_users ||= all_users.order(order_attribute.to_s => order.to_sym)
@ordered_users ||= all_users.order(order_attribute.to_s => order.to_sym).count
@ordered_users ||= all_users.order(order_attribute.to_s => order.to_sym)
 all_users.order(order_attribute.to_s => order.to_sym).flatten
 all_users.order(order_attribute.to_s => order.to_sym)
order.to_sym
order_attribute.to_s
exit
continue
conti
    seached_users.includes(:feedbacks).map(&:feedbacks)
last_feedbacks
seached_feedbacks.any?
seached_users.map(&:feedbacks)
seached_users.count
seached_users
